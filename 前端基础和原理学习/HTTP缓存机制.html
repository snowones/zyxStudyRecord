<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<!--
			注意：当服务器返回304时说明页面使用了这个资源的缓存
			304：如果客户端发送了一个带条件的GET请求且该请求已被允许，而文档的内容（从上次访问以来或是根据请求条件）
				并没有发生变化，则服务器应该返回这个304状态码。简单表达就是：服务端已经执行了GET，但文件并没有发生
				变化。
			
			机制：浏览器在发送请求时，首先会检查强制缓存，如果缓存命中，则不需要发送请求。直接从缓存中获取资源数据，若
			强缓存失效，则发送请求进去协商缓存，服务器通过浏览器请求头Last-Modified和Etag字段进行检查，若是资源则返
			回新的资源数据，200状态码，否则返回304
			
			缓存分两种：1强制缓存 2协商缓存
			
			强制缓存：
				浏览器在发起http请求前首先检查的就是强制缓存，也就是强制缓存并不需要去发送请求，只需要通过携带的字段确
				认实现，在早起的http1.0中是通过Expires字段，后来的http1.1中使用Cache-Control字段
			
			1	Expires是指过期时间。他存在服务器的相应头中，用来告诉浏览器在这个过期时间之前是不需要请求的，可以使用
				缓存内容，但是这个额实现机制中存在一个坑点就是服务器的时间和浏览器的时间可能不一致，这样就会导致过期时
				间不准备，所以http1.1就不用这个字段了，是用来Cache-control字段
			
			2 	Cache-Control和 Expires 最大的区别是它不是采取过期时间点，而是利用过期市场，通过max-age属性来传达
				过期时长，如Cache-Control:max-age:3600, 就表示在一个小时内都可以使用缓存内容。
				
				Cache-Control的其他属性：
					public：表示客服端和代理服务器都可以进行缓存
					private：表示只能客户端缓存
					no-cache：表示跳过当前的强制缓存，发起http请求，直接进入协商缓存
					no-store：表示不进行缓存
					s-maxage: 表示针对代理服务器的缓时间
				
			如果强制缓存失效了，则会发起请求，进入到协商缓存
			
			
			协商缓存：
				在强制缓存失效后，浏览器会在请求头中携带缓存tag向服务器发起请求，服务器根据该tag值去判断是否使用缓存
				，其中tag字段分别为Last-Modified和Etag。
			
			1 Last-modified
				表示最后修改时间，浏览器向服务器发起请求后，服务器会在响应头中加上该字段，在浏览器下一次发送请求时，会
				在请求头中携带If-Modified-Since字段，该字段的值就是服务器传来的最后一次修改时间，服务器拿到这个字段
				值后就会和自身最后修改时间进行对比，如果两者不一样，就说明更新了，返回200，否则返回304告诉浏览器使用
				缓存的数据
				
				Last-modified -》 if-Modified-Since
			
			2 Etag
				表示服务器根据当前文件资源生成的唯一标识，服务器在响应头中将该字段传递给浏览器，浏览器在下次请求时会将
				这个值作为if-None-match字段的内容并放到请求头中，服务器接收到if-None-Match后会跟服务器上的Etag进
				行对比，如果两者不一样，说明更新了，返回200，否则返回304，告诉浏览器使用缓存内容。
				
				Etag -》in-None-Match
				
			二者对比：
				在精度上Etag是优于Last-modified的，因为Etag是根据资源文件内容生成的唯一标示，因为能够准确感知到资源
				文件内容的变化，而Last-modified是通过时间点来感知，可能1s内修改多次，此时就不能体现修改。在性能上
				Last-modified是优于Etag的，Last-Modified仅仅只是记录一个时间点，而Etag需要根据文件的具体内容生成
				哈希值。
			
		-->
		
		<!--
			缓存位置
			
			这个内容再其地方并没有找到详细的资料 先记录下来
			
			浏览器缓存位置共有四种，按优先级来说分别为
			Service Worker
			Memory Cache
			Disk Cache
			Push Cache
			
			Sevice Worker
				它是使JS运行在主线程之外，虽然自己脱离了浏览器，无法访问dom元素，但是它可以实现离线缓存，消息
				推送等，其中离线缓存就是指Service Woker Cache，同时它也是PWA实现的重要机制。
				
			Memory Cache
				它是指内存缓存，它的效率是最快的，但是它的生命周期很短，当渲染进程结束后，它也就不复存在了
			
			Disk Cache
				它是硬盘缓存，它的存取效率会慢一些，但是它的存储量和存储时长相对比较有优势。
			
			Push Cache
				推送缓存是Http2中的内容，目前应用不是很广泛，后续随着http2.0的推广，肯定会备受关注
		-->
	</body>
</html>
