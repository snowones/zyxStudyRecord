<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<!--
			谈一谈对虚拟DOM的理解
				首先虚拟DOM就是通过JS来模拟页面上的DOM和DOM之间的嵌套关系，谈对虚拟DOM的理解主要
				应该是说为什么要有虚拟DOM，对于react这个框架来说，其内部最基础的内容是jsx，我们通
				过jsx来构建了页面，第二点就是如何去更新这个页面。传统页面的更新方式就是去操作DOM树，
				但是操作DOM树是一个很复杂的事情，我们需要知道哪些节点是移动，哪些节点是删除，添加了
				哪些子节点，所以我们肯定是不考虑这件事情的。而更新页面最简单的方式就是，当有数据变动
				时，我们将整个页面重新渲染，但是这样的话速度肯定是很慢的，并且dom树还包含状态，比如
				说我们去滚动页面，或是对于一个元素的聚焦和失焦，显然这时候我们是不需要重新渲染的。所
				以这时我们应该换一种思路，不是全部重新渲染，而是仅仅重新渲染变动的元素，这也就涉及到
				了DOM树的对比，也就是我们说的diff算法。(先不说diff算法)。但对于diff算法，我们对比
				的仅仅是DOM上的节点变化，而真实的DOM树是复杂的，我们可以通过轻量级的DOM树来代替复杂
				的DOM树的对比，也就是虚拟DOM，通过构建一个轻量级的DOM虚拟DOM来和真实的DOM节点一一
				对应，每次更新后仅仅对比新的虚拟DOM和旧的虚拟DOM，然后把差异更新到真实的DOM上，这样
				就大大提高了对比时的性能。
			Diff算法
				Diff策略讲Diff算法分为了三层，这三个策略把Diff算法的时间复杂度带到了O(n),保证了页面构建的速度
				1 tree Diff
					Web UI 中DOM节点跨层级的移动特别少，可以忽略不计
				2 component diff
					拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件会生成不同的树形结构
				3 element diff
					同一层级的一组节点，它们可以通过唯一id进行区分
				
				1 tree Diff
					虚拟DOM进行层级的比较，两个树只会对同一层次的节点进行比较，也就是比较同一父节点
					下的子节点，当发现节点不见了，就直接删除，不在进行其他比较，这样只需要对树进行一
					次遍历就能完成比较。
					原因：DOM节点跨层级的移动操作是一种很不常见的现象，基本可以忽略。
				2 component diff
					两种情况 
					1如果不是同一类型的组件，直接将该组件判断为dirty component，从而替换整个组件下的全部子节点
					2如果是同一类型的组件，继续进行接下来的diff比较，但是在比较前，我们可以通过一些手段来判断该组件
					是否更新，是否需要继续比较，也就是我们通常使用的react优化手段，比如shouldComponentUpData、
					useEffect、useMemo、useCallback 通过判断告诉react这个组件是否需要更新
				3 element diff
					当节点在同一层级时，element定义了三种操作 插入、移动和删除。这也就是我们为什么要写key的理由，
					key帮助了react快速的判断我们的element是插入移动还是删除。
		-->
	</body>
</html>
