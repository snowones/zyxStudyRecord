<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<!--
			谈一谈对虚拟DOM的理解
				首先虚拟DOM就是通过JS来模拟页面上的DOM和DOM之间的嵌套关系，谈对虚拟DOM的理解主要
				应该是说为什么要有虚拟DOM，对于react这个框架来说，其内部最基础的内容是jsx，我们通
				过jsx来构建了页面，第二点就是如何去更新这个页面。传统页面的更新方式就是去操作DOM树，
				但是操作DOM树是一个很复杂的事情，我们需要知道哪些节点是移动，哪些节点是删除，添加了
				哪些子节点，所以我们肯定是不考虑这件事情的。而更新页面最简单的方式就是，当有数据变动
				时，我们将整个页面重新渲染，但是这样的话速度肯定是很慢的，并且dom树还包含状态，比如
				说我们去滚动页面，或是对于一个元素的聚焦和失焦，显然这时候我们是不需要重新渲染的。所
				以这时我们应该换一种思路，不是全部重新渲染，而是仅仅重新渲染变动的元素，这也就涉及到
				了DOM树的对比，也就是我们说的diff算法。(先不说diff算法)。但对于diff算法，我们对比
				的仅仅是DOM上的节点变化，而真实的DOM树是复杂的，我们可以通过轻量级的DOM树来代替复杂
				的DOM树的对比，也就是虚拟DOM，通过构建一个轻量级的DOM虚拟DOM来和真实的DOM节点一一
				对应，每次更新后仅仅对比新的虚拟DOM和旧的虚拟DOM，然后把差异更新到真实的DOM上，这样
				就大大提高了对比时的性能。
			Diff算法
				Diff策略讲Diff算法分为了三层，这三个策略把Diff算法的时间复杂度带到了O(n),保证了页面构建的速度
				1 tree Diff
					Web UI 中DOM节点跨层级的移动特别少，可以忽略不计
				2 component diff
					拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件会生成不同的树形结构
				3 element diff
					同一层级的一组节点，它们可以通过唯一id进行区分
				
				1 tree Diff
					虚拟DOM进行层级的比较，两个树只会对同一层次的节点进行比较，也就是比较同一父节点
					下的子节点，当发现节点不见了，就直接删除，不在进行其他比较，这样只需要对树进行一
					次遍历就能完成比较。
					原因：DOM节点跨层级的移动操作是一种很不常见的现象，基本可以忽略。
				2 component diff
					两种情况 
					1如果不是同一类型的组件，直接将该组件判断为dirty component，从而替换整个组件下的全部子节点
					2如果是同一类型的组件，继续进行接下来的diff比较，但是在比较前，我们可以通过一些手段来判断该组件
					是否更新，是否需要继续比较，也就是我们通常使用的react优化手段，比如shouldComponentUpData、
					useEffect、useMemo、useCallback 通过判断告诉react这个组件是否需要更新
				3 element diff
					当节点在同一层级时，element定义了三种操作 插入、移动和删除。这也就是我们为什么要写key的理由，
					key帮助了react快速的判断我们的element是插入移动还是删除。
		-->
		<!-- 
			Vurtual DOM真的比操作原生DOM快吗？谈谈你的想法
				
				首先从框架设计上来说也就试上面的谈一谈对虚拟DOM的理解，使用虚拟DOM的原因并不是因为他比操作原生DOM快，
				而是因为操作DOM是一件复杂的事情，我们需要寻找一种更新DOM的方式，所以说虚拟DOM比原生DOM快本身就无从谈
				起。
				
				具体分析
				
				1 原生DOM操作 vs 通过框架封装操作
					这是一个性能 VS 可维护性的取舍。框架的意义在于为你掩盖底层的DOM操作，让你用更声明式的方式来描述你的
					目的，从而让你的代码更容易维护。
					没有任何框架可以比纯手动的优化DOM操作更快，因为框架的DOM操作层应对任何上层的API可能产生的操作，它的
					操作时普适化的，针对任何一个benchmark我都可以写出比框架更快的的手动优化，但是那有什么意义呢？在构建
					一个实际应用的时候，你难道为每一个地方都去做手动优化吗？处于可维护性的考虑，这显然是不可能的。框架给
					你的保证是，你在不需要手动优化的情况下，我依然可以给你提供过的去的性能。
					
				2 对React 的 Virtual DOM 的理解。
					最上面那个
					
				3 MVVM vs Virtural DOM
					//这里没仔细学过VUE和Angular 不太明白更新原理
					
					相比起React 其他MVVM系列框架比如Angular、Knockout以及Vue、Avalon采用的都是虚拟绑定：通过
					Directive/Binding对象，观察数据变化并保留对实际DOM元素的引用，当有数据变化时进行对应的操作。
					MVVM的变化检查是数据层面的，而React的检查是DOM结构层面的。
					
					而MVVM的性能也根据变动检测的实现原理有所不同，Angular采用脏检查 Vue采用依赖收集
					具体的先不深究了
				
				4 性能比较需要看场合
					在比较性能的时候，要分清初始渲染，小量数据更新，大量数据更新这些不同的场合。virtual DOM、
					脏检查MVVM、数据收集MVVM在不同的场合各有不同的表现和不同的优化需求。virtual dom 为了提升小数量数据
					更新时的性能，也需要针对性的优化，比如shouldComonentUpdata或是immutable data。
				
					初始化渲染： Virtual DOM > 脏检查 >=依赖手机
					小量数据：依赖收集 > Virtual DOM + 优化 > 脏检查（无法优化）> Virtual DOM无优化
					大量数据更新：脏检查+优化 >= 依赖收集+优化 > Virtual DOM(无法优化/无需优化) > MVVM 无优化
					
					不要天真的以为Virtual DOM就是快，diff不是免费的，batching MVVM也能做，而且最终path的时候还是要
					去调原生API。在我看来Virtual DOM真正的价值从来不是性能，而是1 为函数式的UI编程方式打开的大门 2 可以
					渲染到DOM以外的backend，比如React Native
		-->
	</body>
</html>
