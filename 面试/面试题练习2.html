<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<!--
			map set weakSet weakmap为什么对后面两种对垃圾回收机制友好？
				因为WeakSet只能放置对象，并且WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象
				的引用，也就是，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的空间，不
				考虑该对象是否还存在于WeakSet之中。
				
				这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为0，垃圾回收机制就不会释放这块内存。结束使用
				该值以后有时会忘记取消一弄，导致内存无法释放，进而引发内存泄露。WeakSet里面的引用都不计入垃圾回收机制，
				所以不存在这个问题。也因此，WeakSet适合临时存放一组对象，以及跟对象绑定的信息，只要这些对象在外部消失，
				他在WeakSet里面的引用就会自动消失。
				
				因为上面这个特点，WeakSet的成员是不可引用的，因为它会随时消失。另外由于WeakSet内有多少个成员，取决于垃圾
				回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制的运行时不可预测的，因此ES6规定，
				WeakSet不可遍历。
				
				WeakMap与垃圾回收机制的关系跟WeakSet一模一样。
				WeakMap只接受对象作为键名(null除外)
		-->
		<!--
			clearTimeout(timer) 和 timer = null 有什么区别？
			
			clearTimeout(timer)是在内存中清除掉这个定时器 
			而timer = null 仅仅是改变了timer的指向 让timer这个变量指向了null，并没有真正清除掉定时器。
		-->
		<!--
			let 为什么不会像var一样外泄。
			这里用我自己的话总结，let是块级作用域，var是函数作用域（不一定准备是之前面美团时面试官说的），简单来说就是
			let定义的变量的作用域范围是花括号那个范围，var的范围会穿越全部花括号，比如再一个函数中我们直接写一个花括号
			我们的变量就会定义到花括号外面，并且如果我们再最外层定时var时，变量会直接绑定到window上，我们也可以理解为
			var定义的变量在最外层会穿越script标签绑定到window窗口上，而let定义的只能在定义的script标签中拿到。
		-->
		<!--
			快速排序的时间复杂度和空间复杂度？
			
		-->
	</body>
</html>
